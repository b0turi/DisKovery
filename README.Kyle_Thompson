#################################################################################
									Week 2
#################################################################################

Had quite a few headaches this week trying to convert tutorial code from C/C++ to
Python. Ran into a snag about halfway through the week where some of the really
low level stuff Vulkan does (like calls to memcpy(), sizeof(), offsetof(), etc.)
wasn't gelling well with the Vulkan wrapper I was using and I couldn't figure out
how to properly get C Types with pointers and stuff working using that wrapper.
I found a different Python Vulkan wrapper though that dynamically generates a 
giant Python script that just sits in the same directory, so that's what "vk.py"
is in the "engine_core" folder. I'm in the process of migrating "vulkan_stuff" 
into "engine_core", and I've also been taking the time while migrating to this 
new wrapper to consolidate stuff into fewer modules so the imports aren't as much 
of a headache. Sometime next week I'll probably try to modify our design document 
to reflect the changes in the class structure that resulted. 

"vulkan_stuff" was a very sloppy first run at the core of the engine, and now
that I have more of an idea of what's going on with Vulkan, "engine_core" will
be the place where all my new changes happen. Once I'm done moving everything
over 
In terms of new content, I've added a lot more of the things listed under the 
"Engine Capabilities" section in our design doc. The modules listed below in 
week 1 have moved around a little bit, and there's also some new ones:

	- diskovery_vulkan, diskovery_device_manager, and diskovery_swap_chain 
		have all been merged into diskovery_instance with a new structure

	- diskovery_mesh (new) stores the Vertex and Mesh classes, which can be
		used to load a 3D model from a .obj file using PyWavefront, and 
		stores the data in Buffer objects

	- diskovery_buffer (new) stores the Buffer and UniformBuffer classes.
		Buffer, as listed above, is used in many places to interface with
		the GPU memory management Vulkan handles. It's used when creating 
		Images, Textures, and Meshes. The UniformBuffer class has a list of
		Buffers that store data in GLSL shader modules.

	- diskovery_pipeline now also contains the Shader class, which can 
		dynamically load .glsl and .spv files and stores a definition of the
		uniforms passed into the shader

	- diskovery_descriptor (new) is used inside RenderedEntity to store all 
		the uniform data and vertex data that will be referenced during draw 
		calls. It holds the Descriptor class and some helper methods

	- diskovery_image (new) holds the Image and Texture class. The Image class
		stores an image in Vulkan memory, and the Texture class extends it 
		to load an external image through Pygame and store it in Vulkan's
		virtual memory on the GPU.

Stuff I wanted to get done this week, but got too bogged down to do:
	- diskovery_sync_objects and diskovery_command_buffer merged into a new
		class: EntityManager, which will refresh command buffers each time an
		entity is added or removed, handle the draw calls and synchronizing them
		with the sync objects. 

For next week, my next task is to get the Entity system up and running, which I
already have a good chunk of the way there because it ended up being necessary
to test some earlier stuff. Entity and RenderedEntity are basically finished,
but getting AnimatedEntity working and parsing the animated portions is going to
be a fair amount of work. My goal over the weekend is to get the program running
to the point where an external 3D model can be loaded, displayed on screen, 
and have a texture mapped to it with some basic lighting. By next Friday, I want
to have a 3D character doing a running animation.


#################################################################################
									Week 1
#################################################################################

Lining up with our Gantt chart, I started developing the Vulkan backend of the
engine. I gave myself 2 weeks to do this, and it's looking like I might be able
to get a bit ahead, I had a really productive night on Wednesday. 

In order for the code to run, you need to have the Vulkan SDK installed and the
python modules "vulkan" and "pysdl2" installed on your machine. If you do, you
should see a red triangle with a green background show up when you run 
	
	python ./vulkan_stuff/main.py

Work I did this week:

In ./vulkan_stuff, I added:
	- diskovery.py
		The actual Diskovery module, the top level that all other diskovery
		components will be underneath. Handles initialization, cleanup, and
		drawing the frame
	- diskovery_window.py
		Handles the SDL window (placeholder until integrated with pygame and 
		tkinter), the Vulkan instance, and the surface that connects the two
	- diskovery_device_manager.py
		Handles the selection of the physical device (the graphics card) and
		the creation of the Vulkan logical device. Stores info about queues
	- diskovery_swap_chain.py
		Handles the creation of a VkSwapChainKHR object and other relevant
		info that goes with it. 
	- diskovery_pipeline.py
		Handles the creation of a VkPipeline, VkPipelineLayout, parsing in a
		shader file, and creating a full pipeline from these and a render pass
	- diskovery_command_buffer.py
		Handles the command buffers, which handle draw calls asynchronously.
		Uses a command pool and pulls from it to draw to each individual 
		frame buffer.
	- diskovery_sync_objects.py
		Handles the actual displaying of different frames through semaphores
		and fences. Holds references to these VkSemaphores and VkFences.
	- diskovery_vulkan.py
		Random create methods that weren't big enough to warrant getting their
		own classes around them. Includes VkRenderPass and VkFramebuffer.
	- main.py (tester)
		Just runs Diskovery via Diskovery_Init() and Diskovery_Run()

	frag.spv and vert.spv are ripped from the example included in our Python
	wrapper, and placeholders. Next week we will have original GLSL shaders,
	converted to SPIR-V format realtime.

	The SDL2.dll is necessary for the placeholder SDL window to run. Once we're
	better integrated with pygame we won't need it anymore.

I've been basing this mostly on an example included in the Python wrapper 
we're using:

	https://github.com/realitix/vulkan/blob/master/example/example_sdl2.py

It doesn't have anything about a whole Object-Oriented structure like we're 
trying to set up so I'm adapting as I go, and really just wanted to get 
something on the screen before tidying everything up and making
it look nice, so some of it is pretty ugly for now, I'll also need to add
comments in a lot of places for our autogen Sphinx doc.

For next week, I'll need to add more stuff for customizable shaders, uniform
buffers and the whole system around them, loading textures and sampling them,
and generally cleaning up the code that's here. 
