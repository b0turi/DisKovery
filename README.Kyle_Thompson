#################################################################################
									Week 5
#################################################################################

This week was kind of a stand still. I didn't really make much progress because
we were hung up on trying to embed the Pygame window into the TkInter window.
It just wasn't cooperating and kept resizing the Vulkan surface to be 1 pixel
by 1 pixel and I coudn't get a resize function working for Vulkan, so all the work
I put in this week was just frustrating brick wall after brick wall. We're
probably gonna have the editor be a collection of smaller windows rather than one
big window, kind of like how Gimp works on Mac OS. In terms of actual work we
accomplished, I don't know that there's much to mention. I got the renderers
working together, the main thing that was holding me up last week, that's all in
diskovery_entity_manager.py, but other than that the program still does about
the same amount of stuff. I did add a GUI shader that will be useful for when
we're adding GUI elements with correct proportions for the actual screen rather 
than Vulkan coordinates, but in terms of the color picking application I was
talking about, it became apparent that the rest of the UI will have to be 
developed before that can be added, so that's going to have to wait a bit.

Also, I found out tonight that Jaafar has dropped the class. We're going to need
to do some regrouping come Monday to try and figure out which features are not
going to end up in the final product. We left the last couple weeks to be mainly
for the final paper and anything we weren't able to finish earlier, so hopefully
if we just fill in those weeks and remove some of the stretch goals, it should
still be pretty doable to get a working product, but for this week, we definitely
don't have a minimum viable product. Sometime next week I'll tweak our design
doc to reflect our new plans with just the two of us.

#################################################################################
									Week 4
#################################################################################

Got some nice stuff done this week, but not all stuff that was originally on the
schedule. I've added some nice touches to optimize our rendering and make it look
nicer (mipmapping and anti-aliasing, respectively, if you're familiar with 
graphics programming terms). We're about to start actually taking the stuff I'm 
working on and merging it with Oliver's GUI so that a user can manipulate 3D 
objects so I've been trying to modularize my code so that it can fit together 
with an external UI more easily. I've added a Camera object (default extension of Entity, as described in the design doc) and the view and projection matrices 
defined by the camera are passed to rendered entities whenever they are updated 
so the position of the camera will affect where things are rendered and its
perspective is adjustable (i.e. field of view, draw distance, etc.) I've done a 
lot of restructuring of the core of the engine so that we can render to offscreen 
images rather than just rendering directly to the screen, so we can have the 
color picking algorithm implemented. It should work but it required a bigger 
adjustment than I thought it would and that plus having other midterms this week 
meant I didn't get quite as much done as I had hoped. 

I added documentation for the EntityManager class, but that's now out of date.
There's also a new class I started working on for input in diskovery_input_manager,
but that didn't really get off the ground this week. Most of my work revolved around
the new Renderer class in diskovery_entity_manager, and that's going to be the main
thing that changes in terms of how things are rendered to the screen. 

For over spring break, I'll probably try to wrap up everything I was supposed to
have ready for this week and also try to help Oliver get my window embedded in his
GUI. We had some issues because he was using an IDE for python that used Anacoda
for package management and I'm just working with Sublime Text and using the command
line to compile, and pip for package management. When last we met up Friday 
afternoon I was helping him get the pygame window embedded in his TkInter GUI,
but we weren't able to get both working at the same time because the diskovery
run() method and the TkInter root.mainloop() method are both blocking calls, so 
we need to figure out a way to have them both loop at the same time. Hopefully
by the end of break we'll have those sorted out and we'll be able to start working
out of the same folder within our repository.

#################################################################################
									Week 3
#################################################################################

Pretty good week! Got started on a lot of different things, namely, resolved all 
the issues from last week and I was able to have an external 3D model with an 
external texture mapped to it. I added the EntityManager class I mentioned in a
new module called diskovery_entity_manager.py. I started working on our 
documentation using Sphinx, which we're using primarily with the autodoc 
extension so it can read docstrings directly from our python modules. Some of the 
basic documentation we have so far can be found in 
	
	./engine_core/docs/build/index.html

and the other .html files in that directory. Additionally, I cleaned up a lot of 
the code from weeks prior, removing all unnecessary parameters in Vulkan calls 
that were included in the tutorials for educational purposes (mostly in 
diskovery_instance.py and diskovery_entity_manager.py). The tutorial code used 
some primitive math functions the author had written to handle vector and matrix
operations, so I swapped that out for PyGLM, a Python wrapper for the standard
math library that accompanies OpenGL/Vulkan, so that we could use Quaternions for
the rotation values of animated models. I added some wrapping tweaks of my
own so that the data could be passed to buffers as C types not Python values.

As of when I was writing this, I don't quite have animations handled yet. I have
a lot of the architecture in place for it (all located in diskovery_mesh.py), 
but I haven't gotten to the point where the animations can be loaded externally 
and played on the model. I have written a new shader to handle the animations
(animated.vert), reworked the way that uniform data objects are stored (new class
UniformBufferObject that MVPMatrix and JointData extend, all located in new file
diskovery_ubos.py). 

I was able to finish the Collada parser for 3D models, and am still working on
getting them done for animations and rigs. Hopefully by midnight tonight I'll 
have that working. In terms of for next week, Oliver and I are going to start
merging our work and my portion will exist as the center of the GUI window he's
been working on. I'm going to try to get mouse picking working on a 3D window
using a color based picking model that requires rendering to another framebuffer.
Hopefully it'll work, but I'm not sure because I've only done things like this 
in OpenGL, not Vulkan. I might need to change the way I'm planning on
implementing it but that'll probably be for over spring break.

Side note: I know right now I have a lot more work in than Oliver does, but it's
not a case of Oliver not pulling his weight, please don't mark him down because
he's not matching the huge amount I'm doing. I'm basically doubling up doing the
portions that Jaafar would be doing because Oliver is a lot less familiar with
this kind of stuff so we can't even really go 50/50 on this extra stuff. 

#################################################################################
									Week 2
#################################################################################

Had quite a few headaches this week trying to convert tutorial code from C/C++ to
Python. Ran into a snag about halfway through the week where some of the really
low level stuff Vulkan does (like calls to memcpy(), sizeof(), offsetof(), etc.)
wasn't gelling well with the Vulkan wrapper I was using and I couldn't figure out
how to properly get C Types with pointers and stuff working using that wrapper.
I found a different Python Vulkan wrapper though that dynamically generates a 
giant Python script that just sits in the same directory, so that's what "vk.py"
is in the "engine_core" folder. I'm in the process of migrating "vulkan_stuff" 
into "engine_core", and I've also been taking the time while migrating to this 
new wrapper to consolidate stuff into fewer modules so the imports aren't as much 
of a headache. Sometime next week I'll probably try to modify our design document 
to reflect the changes in the class structure that resulted. 

"vulkan_stuff" was a very sloppy first run at the core of the engine, and now
that I have more of an idea of what's going on with Vulkan, "engine_core" will
be the place where all my new changes happen. Once I'm done moving everything
over 
In terms of new content, I've added a lot more of the things listed under the 
"Engine Capabilities" section in our design doc. The modules listed below in 
week 1 have moved around a little bit, and there's also some new ones:

	- diskovery_vulkan, diskovery_device_manager, and diskovery_swap_chain 
		have all been merged into diskovery_instance with a new structure

	- diskovery_mesh (new) stores the Vertex and Mesh classes, which can be
		used to load a 3D model from a .obj file using PyWavefront, and 
		stores the data in Buffer objects

	- diskovery_buffer (new) stores the Buffer and UniformBuffer classes.
		Buffer, as listed above, is used in many places to interface with
		the GPU memory management Vulkan handles. It's used when creating 
		Images, Textures, and Meshes. The UniformBuffer class has a list of
		Buffers that store data in GLSL shader modules.

	- diskovery_pipeline now also contains the Shader class, which can 
		dynamically load .glsl and .spv files and stores a definition of the
		uniforms passed into the shader

	- diskovery_descriptor (new) is used inside RenderedEntity to store all 
		the uniform data and vertex data that will be referenced during draw 
		calls. It holds the Descriptor class and some helper methods

	- diskovery_image (new) holds the Image and Texture class. The Image class
		stores an image in Vulkan memory, and the Texture class extends it 
		to load an external image through Pygame and store it in Vulkan's
		virtual memory on the GPU.

Stuff I wanted to get done this week, but got too bogged down to do:
	- diskovery_sync_objects and diskovery_command_buffer merged into a new
		class: EntityManager, which will refresh command buffers each time an
		entity is added or removed, handle the draw calls and synchronizing them
		with the sync objects. 

For next week, my next task is to get the Entity system up and running, which I
already have a good chunk of the way there because it ended up being necessary
to test some earlier stuff. Entity and RenderedEntity are basically finished,
but getting AnimatedEntity working and parsing the animated portions is going to
be a fair amount of work. My goal over the weekend is to get the program running
to the point where an external 3D model can be loaded, displayed on screen, 
and have a texture mapped to it with some basic lighting. By next Friday, I want
to have a 3D character doing a running animation.


#################################################################################
									Week 1
#################################################################################

Lining up with our Gantt chart, I started developing the Vulkan backend of the
engine. I gave myself 2 weeks to do this, and it's looking like I might be able
to get a bit ahead, I had a really productive night on Wednesday. 

In order for the code to run, you need to have the Vulkan SDK installed and the
python modules "vulkan" and "pysdl2" installed on your machine. If you do, you
should see a red triangle with a green background show up when you run 
	
	python ./vulkan_stuff/main.py

Work I did this week:

In ./vulkan_stuff, I added:
	- diskovery.py
		The actual Diskovery module, the top level that all other diskovery
		components will be underneath. Handles initialization, cleanup, and
		drawing the frame
	- diskovery_window.py
		Handles the SDL window (placeholder until integrated with pygame and 
		tkinter), the Vulkan instance, and the surface that connects the two
	- diskovery_device_manager.py
		Handles the selection of the physical device (the graphics card) and
		the creation of the Vulkan logical device. Stores info about queues
	- diskovery_swap_chain.py
		Handles the creation of a VkSwapChainKHR object and other relevant
		info that goes with it. 
	- diskovery_pipeline.py
		Handles the creation of a VkPipeline, VkPipelineLayout, parsing in a
		shader file, and creating a full pipeline from these and a render pass
	- diskovery_command_buffer.py
		Handles the command buffers, which handle draw calls asynchronously.
		Uses a command pool and pulls from it to draw to each individual 
		frame buffer.
	- diskovery_sync_objects.py
		Handles the actual displaying of different frames through semaphores
		and fences. Holds references to these VkSemaphores and VkFences.
	- diskovery_vulkan.py
		Random create methods that weren't big enough to warrant getting their
		own classes around them. Includes VkRenderPass and VkFramebuffer.
	- main.py (tester)
		Just runs Diskovery via Diskovery_Init() and Diskovery_Run()

	frag.spv and vert.spv are ripped from the example included in our Python
	wrapper, and placeholders. Next week we will have original GLSL shaders,
	converted to SPIR-V format realtime.

	The SDL2.dll is necessary for the placeholder SDL window to run. Once we're
	better integrated with pygame we won't need it anymore.

I've been basing this mostly on an example included in the Python wrapper 
we're using:

	https://github.com/realitix/vulkan/blob/master/example/example_sdl2.py

It doesn't have anything about a whole Object-Oriented structure like we're 
trying to set up so I'm adapting as I go, and really just wanted to get 
something on the screen before tidying everything up and making
it look nice, so some of it is pretty ugly for now, I'll also need to add
comments in a lot of places for our autogen Sphinx doc.

For next week, I'll need to add more stuff for customizable shaders, uniform
buffers and the whole system around them, loading textures and sampling them,
and generally cleaning up the code that's here. 
